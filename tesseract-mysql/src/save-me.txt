use failure::Error;
use futures::future::Future;
use std::time::Instant;
use tesseract_core::{Backend, DataFrame};
use futures::future::ok;
use failure::err_msg;

extern crate mysql;
use mysql as my;
use mysql::consts::ColumnType;

mod df;
use self::df::queryresult_to_df;

#[derive(Clone)]
pub struct MySql {
    options: String
}

impl MySql {
    pub fn from_addr(address: &str) -> Result<Self, Error> {
        Ok(MySql {
            options: address.to_string(),
        })
    }
}

impl Backend for MySql {
    fn exec_sql(&self, sql: String) -> Box<Future<Item=DataFrame, Error=Error>> {
        // let time_start = Instant::now();
        let pool = my::Pool::new(self.options.to_string());

        let dburl = "mysql://dbuser:Jh8zX4k%2FYP9wd3HC4@opencompass.datawheel.us:3306/gh_cooked";
        let pool = my::Pool::new(dburl).unwrap();
        let y = pool.prep_exec(r"SELECT project_id, commits from project_facts LIMIT 10", ());
        let z = queryresult_to_df(y.expect("Query Failed!"));

        // let future1 = pool.get_conn()
        //     .and_then(|conn| {
        //         conn.prep_exec("SELECT 1", ());
        //         ok(DataFrame::new())
        //     })
        //     .map_err(|e| {
        //         err_msg(e.description().to_string())
        //     });



//         Box::new(future1)
//     }

//     fn box_clone(&self) -> Box<dyn Backend + Send + Sync> {
//         Box::new((*self).clone())
//     }
// }


#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_add1() {
        let dburl = "mysql://dbuser:Jh8zX4k%2FYP9wd3HC4@opencompass.datawheel.us:3306/gh_cooked";
        let pool = my::Pool::new(dburl).unwrap();
        let y = pool.prep_exec(r"SELECT project_id, commits from project_facts LIMIT 10", ());
        let z = queryresult_to_df(y.expect("Query Failed!"));

            // .map(|result| {
            //     let cols = result.columns_ref();
            //     let my_kinds: Vec<ColumnType> = cols.iter().map(|c| { c.column_type() }).collect();
            //     println!("{:?}", cols[0]);
            //     println!("{:?}", my_kinds)
            // });
    
        println!("1. HERE WE ARE!!!!!!! {:?}", z);

        // let db = MySql::from_addr("mysql://dbuser:Jh8zX4k%2FYP9wd3HC4@opencompass.datawheel.us:3306/github").unwrap();
        // let z = db.exec_sql("SELECT 1".to_string())
        //     .and_then(move |result| {
        //         println!("query complete!");
        //         println!("{:?}", result);
        //         ok(1)
        // //     });
        // // assert_eq!(z.wait().unwrap(), 1);
        // let pool = my::Pool::new("mysql://dbuser:Jh8zX4k%2FYP9wd3HC4@opencompass.datawheel.us:3306/github");

        //         let future2 = pool.get_conn()
        //     .and_then(|conn| {
        //         conn.prep_exec("SELECT 1 as chicky", ())
        //     })
        //     .and_then(|p| {
        //         println!("GOT HERE!");
        //         let (stmt, columns, cached) = query_result::disassemble(p);
        //         println!("C {:?}", columns.unwrap()[0]);
        //         // ok(query_result::assemble(stmt, columns, cached))
        //         ok(1)
        //         // p.get_row_raw;

        //         // let (conn_like, cached) = stmt.unwrap();

        //         // query_result::assemble(conn_like, columns, cached)
        //         // p.map_and_drop(|row| {

        //         //     let z: u64 = my::from_row(row);
        //         //     println!("row {}", z);
        //         // })
        //     });
        //     // .and_then(|p| {
        //     //     // The destructor of a connection will return it to the pool,
        //     //     // but pool should be disconnected explicitly because it's
        //     //     // an asynchronous procedure.
        //     //     pool.disconnect().map(|_| p)
        //     // });

        // let x = future2.wait().unwrap();
    }


}
